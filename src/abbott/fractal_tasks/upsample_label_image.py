"""Fractal task to upsample a label image to highest image resolution."""

import logging
from pathlib import Path
from typing import Optional

import anndata as ad
import dask.array as da
import fractal_tasks_core
import numpy as np
import zarr
from fractal_tasks_core.labels import prepare_label_group
from fractal_tasks_core.ngff import load_NgffImageMeta
from fractal_tasks_core.pyramids import build_pyramid
from fractal_tasks_core.roi import (
    array_to_bounding_box_table,
    check_valid_ROI_indices,
    convert_indices_to_regions,
    convert_ROI_table_to_indices,
    create_roi_table_from_df_list,
    load_region,
)
from fractal_tasks_core.tables import write_table
from fractal_tasks_core.tasks.io_models import InitArgsRegistrationConsensus
from fractal_tasks_core.utils import rescale_datasets
from pydantic import validate_call
from scipy.ndimage import zoom

__OME_NGFF_VERSION__ = fractal_tasks_core.__OME_NGFF_VERSION__

logger = logging.getLogger(__name__)


@validate_call
def upsample_label_image(
    # Fractal parameters
    zarr_url: str,
    init_args: InitArgsRegistrationConsensus,
    # Core parameters
    label_name: str,
    input_ROI_table: str,
    output_label_name: Optional[str] = None,
    output_ROI_table: Optional[str] = None,
    level: int = 0,
    overwrite: bool = True,
) -> None:
    """Upsample a label image to match level 0 image resolution.

    This task loads the label image, upsamples it to the highest resolution,
    consolidates the label image to all other levels and saves it back to the
    OME-Zarr file.

    This task is useful if e.g. segmentation was performed at a lower resolution
    due to memory constraints.

    Args:
        zarr_url: Path or url to the individual OME-Zarr image to be processed.
            (standard argument for Fractal tasks, managed by Fractal server).
        init_args: Intialization arguments provided by
            `init_group_by_well_for_multiplexing`. They contain the
            reference_zarr_url that contains the label image to upsample.
            (standard argument for Fractal tasks, managed by Fractal server).
        label_name: Name of the label image to upsample.
        output_label_name: Optionally new label name for the upsampled label image.
        input_ROI_table: Name of the ROI table over which the task loops to
            upsample label images. Examples: `FOV_ROI_table` => loop over
            the field of views, `organoid_ROI_table` => loop over the organoid
            ROI table (generated by another task), `well_ROI_table` => process
            the whole well as one image.
        output_ROI_table: If provided, a ROI table with that name is created,
            which will contain the bounding boxes of the newly upsampled
            labels. ROI tables should have `ROI` in their name. Can be the same
            as `input_ROI_table` if it should be overwritten.
        level: Desired pyramid level of the OME-Zarr label image. Pyramid level
            "0" resolution is retrieved from OME-Zarr image metadata.
            Currently only implemented for "0".
        overwrite: If `True`, overwrite existing label.
    """
    logger.info(f"Starting label upsampling for {zarr_url=} and {label_name=}")

    if level != 0:
        raise NotImplementedError("Only level 0 is supported at the moment.")

    # Check if label actually exists
    label_zarr_url = Path(f"{zarr_url}/labels/{label_name}")
    if not label_zarr_url.exists():
        raise FileNotFoundError(
            f"Label {label_name} does not exist in " f"{zarr_url}. Aborting ... "
        )

    # Set output label name
    if output_label_name is None:
        output_label_name = label_name

    # Read ROI table
    ROI_table_path = f"{zarr_url}/tables/{input_ROI_table}"
    ROI_table = ad.read_zarr(ROI_table_path)

    # Read attributes from zarr_url NGFF metadata
    ngff_image_meta = load_NgffImageMeta(zarr_url)
    num_levels = ngff_image_meta.num_levels
    coarsening_xy = ngff_image_meta.coarsening_xy
    full_res_pxl_sizes_zyx = ngff_image_meta.get_pixel_sizes_zyx(level=level)

    # Load ZYX image data as reference for shape etc.
    # Workaround for #788: Only load channel index when there is a channel
    # dimension
    if ngff_image_meta.axes_names[0] != "c":
        data_zyx = da.from_zarr(f"{zarr_url}/{0}")
    else:
        data_zyx = da.from_zarr(f"{zarr_url}/{0}")[0]

    logger.info(f"{data_zyx.shape=}")

    # Read attributes from label_zarr_url NGFF metadata
    label_ngff_image_meta = load_NgffImageMeta(label_zarr_url.as_posix())
    actual_res_pxl_sizes_zyx = label_ngff_image_meta.get_pixel_sizes_zyx(level=level)

    # Check if upsampling is needed
    if actual_res_pxl_sizes_zyx == full_res_pxl_sizes_zyx:
        logger.info("Label image already at full resolution. No upsampling needed.")
        return

    # Rescale datasets (only relevant for level>0)
    if ngff_image_meta.axes_names[0] != "c":
        raise ValueError(
            "Cannot set `remove_channel_axis=True` for multiscale "
            f"metadata with axes={ngff_image_meta.axes_names}. "
            'First axis should have name "c".'
        )
    new_datasets = rescale_datasets(
        datasets=[ds.model_dump() for ds in ngff_image_meta.datasets],
        coarsening_xy=coarsening_xy,
        reference_level=level,
        remove_channel_axis=True,
    )

    # Prepare label attributes
    label_attrs = {
        "image-label": {
            "version": __OME_NGFF_VERSION__,
            "source": {"image": "../../"},
        },
        "multiscales": [
            {
                "name": output_label_name,
                "version": __OME_NGFF_VERSION__,
                "axes": [
                    ax.model_dump()
                    for ax in ngff_image_meta.multiscale.axes
                    if ax.type != "channel"
                ],
                "datasets": new_datasets,
            }
        ],
    }

    # Prepare new output label
    image_group = zarr.group(zarr_url)

    label_group = prepare_label_group(
        image_group,
        output_label_name,
        overwrite=overwrite,
        label_attrs=label_attrs,
        logger=logger,
    )

    logger.info(f"Helper function `prepare_label_group` returned {label_group=}")
    current_label_path = f"{zarr_url}/labels/{output_label_name}/0"
    logger.info(f"Output label path: {current_label_path}")
    store = zarr.storage.FSStore(current_label_path)
    label_dtype = np.uint32

    # Ensure that all output shapes & chunks are 3D (for 2D data: (1, y, x))
    # https://github.com/fractal-analytics-platform/fractal-tasks-core/issues/398
    shape = data_zyx.shape
    if len(shape) == 2:
        shape = (1, *shape)
    chunks = data_zyx.chunksize
    if len(chunks) == 2:
        chunks = (1, *chunks)
    mask_zarr = zarr.create(
        shape=shape,
        chunks=chunks,
        dtype=label_dtype,
        store=store,
        overwrite=False,
        dimension_separator="/",
    )

    logger.info(
        f"mask will have shape {data_zyx.shape} " f"and chunks {data_zyx.chunks}"
    )

    ##############
    #  Start upsampling
    ##############

    # Create list of indices for 3D ROIs spanning the entire Z direction
    list_indices = convert_ROI_table_to_indices(
        ROI_table,
        level=level,
        coarsening_xy=coarsening_xy,
        full_res_pxl_sizes_zyx=actual_res_pxl_sizes_zyx,
    )

    check_valid_ROI_indices(list_indices, input_ROI_table)
    num_ROIs = len(list_indices)

    label_dask = da.from_zarr(f"{label_zarr_url}/{level}")

    # Loop over the list of indices and perform upsampling for each ROI
    if output_ROI_table:
        bbox_dataframe_list = []
    logger.info(f"Now starting loop over {num_ROIs} ROIs")

    for i_ROI, indices in enumerate(list_indices):
        region = convert_indices_to_regions(indices)

        logger.info(f"Now processing ROI {i_ROI+1}/{num_ROIs}")

        # Compute upsampled label image
        label_image = load_region(data_zyx=label_dask, region=region, compute=True)
        new_label_image, zoom_factor = upsample(
            label_image, actual_res_pxl_sizes_zyx, full_res_pxl_sizes_zyx
        )
        logger.info(f"Finished upsampling for ROI {i_ROI + 1}/{num_ROIs}.")

        # We also need to upsample the region
        upsampled_region = []
        for i, (reg, z) in enumerate(zip(region, zoom_factor)):
            start = reg.start * z
            stop = min(start + new_label_image.shape[i], mask_zarr.shape[i])
            upsampled_region.append(slice(start, stop))

        upsampled_origin_zyx = tuple(s.start for s in upsampled_region)

        if output_ROI_table:
            bbox_df = array_to_bounding_box_table(
                new_label_image,
                full_res_pxl_sizes_zyx,
                origin_zyx=upsampled_origin_zyx,
            )

            bbox_dataframe_list.append(bbox_df)

        # Compute and store 0-th level to disk
        da.array(new_label_image).to_zarr(
            url=mask_zarr,
            region=tuple(upsampled_region),
            compute=True,
        )

    logger.info(
        f"Label upsampling done for {output_label_name=} now building pyramids."
    )

    # Starting from on-disk highest-resolution data, build and write to disk a
    # pyramid of coarser levels
    build_pyramid(
        zarrurl=f"{zarr_url}/labels/{output_label_name}",
        overwrite=overwrite,
        num_levels=num_levels,
        coarsening_xy=coarsening_xy,
        chunksize=chunks,
        aggregation_function=np.max,
    )
    logger.info("End building pyramids")

    if output_ROI_table:
        bbox_table = create_roi_table_from_df_list(bbox_dataframe_list)
        # Write to zarr group
        image_group = zarr.group(zarr_url)
        logger.info(
            "Now writing bounding-box ROI table to "
            f"{zarr_url}/tables/{output_ROI_table}"
        )
        table_attrs = {
            "type": "masking_roi_table",
            "region": {"path": f"../labels/{output_label_name}"},
            "instance_key": "label",
        }
        write_table(
            image_group,
            output_ROI_table,
            bbox_table,
            overwrite=overwrite,
            table_attrs=table_attrs,
        )

    logger.info(f"End upsampling labels task for {zarr_url}/labels/{output_label_name}")


def upsample(label_image_low_res, low_res_pixel_size, full_res_pixel_size):
    """Upsample low res label image to full res (level 0)"""
    zoom_factor = np.floor_divide(low_res_pixel_size, full_res_pixel_size).astype(int)
    upsampled_label_image = zoom(label_image_low_res, zoom_factor, order=0)

    return upsampled_label_image, zoom_factor


if __name__ == "__main__":
    from fractal_task_tools.task_wrapper import run_fractal_task

    run_fractal_task(
        task_function=upsample_label_image,
        logger_name=logger.name,
    )
